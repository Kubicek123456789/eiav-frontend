import express from 'express';
import http from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { Pool } from 'pg';
import cookieParser from 'cookie-parser';
import multer from 'multer';
import { createClient } from '@supabase/supabase-js';

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: process.env.FRONTEND_URL, credentials: true },
});

app.use(cors({ origin: process.env.FRONTEND_URL, credentials: true }));
app.use(express.json());
app.use(cookieParser());

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_KEY!);
const upload = multer({ storage: multer.memoryStorage() });

const JWT_SECRET = process.env.JWT_SECRET!;

// Auth Middleware
const authenticate = async (req: any, res: any, next: any) => {
  const token = req.cookies.access_token;
  if (!token) return res.status(401).json({ message: 'No token' });

  try {
    const payload = jwt.verify(token, JWT_SECRET) as any;
    req.userId = payload.userId;
    next();
  } catch (err) {
    res.status(401).json({ message: 'Invalid token' });
  }
};

// Routes
app.post('/api/auth/signup', async (req, res) => {
  const { username, password, displayName } = req.body;
  const passwordHash = await bcrypt.hash(password, 10);

  try {
    const result = await pool.query(
      'INSERT INTO users (username, password_hash, display_name) VALUES ($1, $2, $3) RETURNING id, username, display_name',
      [username, passwordHash, displayName || username]
    );
    const user = result.rows[0];
    const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' });
    res.cookie('access_token', token, { httpOnly: true, secure: true, sameSite: 'strict' });
    res.json({ user });
  } catch (err: any) {
    if (err.code === '23505') res.status(400).json({ message: 'Username taken' });
    else res.status(500).json({ message: 'Server error' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  const { username, password } = req.body;
  const result = await pool.query('SELECT * FROM users WHERE username = $1', [username]);
  const user = result.rows[0];

  if (!user || !(await bcrypt.compare(password, user.password_hash))) {
    return res.status(401).json({ message: 'Invalid credentials' });
  }

  const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' });
  res.cookie('access_token', token, { httpOnly: true, secure: true, sameSite: 'strict' });
  res.json({ user: { id: user.id, username: user.username, displayName: user.display_name } });
});

app.get('/api/users/me', authenticate, async (req, res) => {
  const result = await pool.query('SELECT id, username, display_name, avatar_url FROM users WHERE id = $1', [req.userId]);
  res.json(result.rows[0]);
});

app.post('/api/uploads', authenticate, upload.single('file'), async (req, res) => {
  if (!req.file) return res.status(400).json({ message: 'No file' });

  const { data, error } = await supabase.storage
    .from('media')
    .upload(`public/${Date.now()}-${req.file.originalname}`, req.file.buffer, {
      contentType: req.file.mimetype,
    });

  if (error) return res.status(500).json({ message: 'Upload failed' });

  const { data: { publicUrl } } = supabase.storage.from('media').getPublicUrl(data.path);
  res.json({ url: publicUrl });
});

// WebSocket
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  try {
    const payload = jwt.verify(token, JWT_SECRET) as any;
    socket.userId = payload.userId;
    next();
  } catch (err) {
    next(new Error('Authentication error'));
  }
});

io.on('connection', (socket) => {
  pool.query('UPDATE users SET is_online = true WHERE id = $1', [socket.userId]);

  socket.on('joinChat', (chatId) => {
    socket.join(chatId);
  });

  socket.on('sendMessage', async (data) => {
    const result = await pool.query(
      'INSERT INTO messages (chat_id, sender_id, type, content) VALUES ($1, $2, $3, $4) RETURNING *',
      [data.chatId, socket.userId, data.type, data.content]
    );
    const msg = result.rows[0];
    io.to(data.chatId).emit('newMessage', msg);
  });

  socket.on('disconnect', () => {
    pool.query('UPDATE users SET is_online = false, last_seen = NOW() WHERE id = $1', [socket.userId]);
  });
});

server.listen(4000, () => console.log('Server running on port 4000'));
